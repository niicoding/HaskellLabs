{- ##################################
 Zachary Perales
 3/6/2020
 Homework 3
 ################################## -}
module Prog3 where

-- This function "takes a list of ints, and returns a list of pairs, such that the first element in each pair [is the] original number, and the second element is the original number doubled" (Burns, Richard. “PDF.” 20 Feb. 2020.).
doubleAll :: [Int] -> [(Int, Int)]
doubleAll x = [(y, y*2) | y <- x]

-- This function "returns the product of the last numbers in the list, where n is the first argument to the function" (Burns, Richard. “PDF.” 20 Feb. 2020.). If 0 is entered, it returns 1, because that's what product does.
productLastPart :: Int -> [Int] -> Int
productLastPart d x = product (drop (length x - d) x)

-- This function has "identical behavior to the init function" (Burns, Richard. “PDF.” 20 Feb. 2020.). It returns all of the elements of a list except the last one (Haskell Quickdocs).
init' :: [Int] -> [Int]
init' x = reverse (tail (reverse x))

-- This function "takes a string argument and returns [True] if it is a nesting of zero or more pairs of parentheses" (Burns, Richard. “PDF.” 20 Feb. 2020.). Here, it is assumed that there may be 0 parentheses, or there is one pair of parentheses, but 0 nestings. Both will return True.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -- nestedParens' :: String -> Bool                                                                                                                                                                                                                                                                                                                                                          
nestedParens :: String -> Bool                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -- nestedParens' ("") = True
nestedParens x = if (length x == 0) then True else if (head x == '(' && head (reverse x) == ')') then nestedParens (reverse (tail (reverse (tail x)))) else False                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -- nestedParens' x = nestedParens (reverse (tail (reverse (tail x)))) && (head x == '(' && head (reverse x) == ')')

-- This returns False for empty string, and False for "()".
-- nestedParens' :: String -> Bool 
-- nestedParens' x = if (length x <= 2) then False else if (head x == '(' && head (reverse x) == ')') then nestedParens (reverse (tail (reverse (tail x)))) else False

-- This returns False for empty string, and True for "()".
-- nestedParens'' :: String -> Bool
-- nestedParens'' x = if (length x == 0) then False else if (head x == '(' && head (reverse x) == ')') then nestedParens (reverse (tail (reverse (tail x)))) else False

-- This function "generates a list of integer triples, such that [x^2 + y^2 = z^2] and x,y,z <= n" (Burns, Richard. “PDF.” 20 Feb. 2020.).
triads :: Int -> [(Int, Int, Int)]
triads maxZ = [(x, y, z) | x <- [0 .. maxZ], y <- [0 .. maxZ], z <- [0 .. maxZ], (x^2 + y^2) == z^2]

-- This function "takes a string and an integer n and forms a string of length by n by putting spaces at the front of the string" (Burns, Richard. “PDF.” 20 Feb. 2020.).
pushRight :: String -> Int -> String
pushRight s x = take (x - length(s)) "                                        " ++ s

-- This function "lowercases the first character in a string" (Burns, Richard. “PDF.” 20 Feb. 2020.). 
lowerFirstCharacter :: String -> String                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   -- lowerFirstCharacter' :: String -> String
lowerFirstCharacter s = if (length s == 0) then s else if ((fromEnum(s!!0) > 64) && (fromEnum(s!!0) < 91)) then (toEnum(fromEnum(s!!0) + 32) :: Char):(tail s) else s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -- lowerFirstCharacter' s = if (s == []) then [ec | ec <- s] else if ((fromEnum(s!!0) > 64) && (fromEnum(s!!0) < 91) && length s == 1) then [(toEnum(fromEnum(onec) + 32) :: Char) | onec <- s] else if ((fromEnum(s!!0) > 64) && (fromEnum(s!!0) < 91)) then [(toEnum(fromEnum(fc) + 32) :: Char) | fc <- (head s):[]]++[restc | restc <- tail s] else [oc | oc <- s]

-- This function "returns the second word in a string that is composed of exactly three words" (Burns, Richard. “PDF.” 20 Feb. 2020.). The string is delimited by whitespace.
middleWord :: String -> String
middleWord s = drop (head ([i | i <- [0 .. ((length s) - 1)], fromEnum(s!!i) == 32]) + 1) (take (head (reverse ([i | i <- [0 .. ((length s) - 1)], fromEnum(s!!i) == 32]))) s)

-- This function "lowercases the first uppercase letter in a string" (Burns, Richard. “PDF.” 20 Feb. 2020.).              
lowerFirstLetter :: String -> String                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -- lowerFirstLetter' :: String -> String
lowerFirstLetter s = if ([i | i <- [0 .. ((length s) - 1)], fromEnum(s!!i) > 64, fromEnum(s!!i) < 91] /= []) then                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -- lowerFirstLetter' s = if ([i | i <- [0 .. ((length s) - 1)], fromEnum(s!!i) > 64, fromEnum(s!!i) < 91] /= []) then
                     take (head[i | i <- [0 .. ((length s) - 1)], fromEnum(s!!i) > 64, fromEnum(s!!i) < 91]) s ++                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -- take (head[i | i <- [0 .. ((length s) - 1)], fromEnum(s!!i) > 64, fromEnum(s!!i) < 91]) s ++
                     (toEnum(fromEnum(s!!head[i | i <- [0 .. ((length s) - 1)], fromEnum(s!!i) > 64, fromEnum(s!!i) < 91]) + 32) :: Char) :                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -- (toEnum(fromEnum(s!!head[i | i <- [0 .. ((length s) - 1)], fromEnum(s!!i) > 64, fromEnum(s!!i) < 91]) + 32) :: Char) :
                     (drop (head[i | i <- [0 .. ((length s) - 1)], fromEnum(s!!i) > 64, fromEnum(s!!i) < 91] + 1) s) else s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -- (drop (head[i | i <- [0 .. ((length s) - 1)], fromEnum(s!!i) > 64, fromEnum(s!!i) < 91] + 1) s) else [oc | oc <- s]

-- This function "lowercases the first two uppercase letter in a string" (Burns, Richard. “PDF.” 20 Feb. 2020.). It just calls the previous function twice.
lowerFirstTwoLetters :: String -> String
lowerFirstTwoLetters s = lowerFirstLetter (lowerFirstLetter s)